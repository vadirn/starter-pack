/**
 * Creates observable value
 * @param initialValue {*=}
 * @returns {Observable}
 */
export function observable(initialValue) {
  let currentValue = initialValue;
  const subscribers = [];

  const iterateSubscribers = value => {
    subscribers.slice().forEach(s => s(value));
  };

  const _subscribe = listeners => {
    subscribers.push(...listeners);
    if (DEV_MODE && subscribers.length > 4) {
      console.warn(
        `Number of subscribers is above threshold (${subscribers.length})`,
        currentValue
      );
    }
    for (const listener of listeners) {
      listener(currentValue);
    }
    return () => {
      for (const listener of listeners) {
        const index = subscribers.indexOf(listener);
        if (index >= 0) {
          subscribers.splice(index, 1);
        }
      }
    };
  };

  /**
   * Subscribe to observable value updates
   * @callback Observable~subscribe
   * {(listener: (currentValue: *) => void) => void|Array<(listener: (currentValue: *) => void) => void>}
   */
  const subscribe = listeners => {
    // eslint-disable-next-line no-ternary
    return _subscribe(Array.isArray(listeners) ? listeners : [listeners]);
  };

  /**
   * Set value of observable
   * @callback Observable~set
   * {(newValue: *=) => void}
   */
  const set = newValue => {
    currentValue = newValue;
    iterateSubscribers(currentValue);
    return currentValue;
  };

  /**
   * @typedef Observable {Object}
   * @property set {Observable~set}
   * @property subscribe {Observable~subscribe}
   * @property current {*} Contains current observable value
   */
  return {
    subscribe,
    set,
    get current() {
      return currentValue;
    },
  };
}

/**
 * Combines given observables into a new one
 * @param observables {...(Observable|DerivedObservable)}
 */
export function combined(...observables) {
  const value = observable();
  const set = () => value.set(observables.map(o => o.current));
  const unsubscribers = observables.map(o => o.subscribe(set));

  /**
   * @typedef DerivedObservable
   * @property complete {function(): void} Unsubscribe from source observables
   * @property subscribe {Observable~subscribe}
   * @property current {*} Contains current observable value
   */
  return {
    subscribe: value.subscribe,
    complete: () => {
      observables.forEach(o => o.complete?.());
      unsubscribers.forEach(u => u());
    },
    get current() {
      return value.current;
    },
  };
}

/**
 * Creates a new observable from a given one by applying a mapper function to its value
 * @param o {Observable|DerivedObservable}
 * @param mapper {function(*, *): *}
 * @returns {DerivedObservable}
 */
export function derived(o, mapper) {
  const value = observable();
  const unsubscribe = o.subscribe(v => {
    const newValue = mapper(v, value.current);
    if (newValue !== undefined) {
      value.set(newValue);
    }
  });

  return {
    subscribe: value.subscribe,
    complete: () => {
      o.complete?.();
      unsubscribe();
    },
    get current() {
      return value.current;
    },
  };
}

/**
 * Sets value of observable if it is different from the current one
 * @param o {Observable}
 * @param newValue {*}
 */
export function setChanged(o, newValue) {
  if (o.current !== newValue) {
    o.set(newValue);
  }
}
