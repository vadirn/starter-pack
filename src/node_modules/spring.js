import { observable } from 'observable';
import { loop } from 'loop';
import { AbortError, assert } from 'errors';
import { rafThrottle } from 'fn-helpers/raf-throttle';

const stepTime = 1 / 60;

function repeat(n, fn, ...args) {
  for (let i = 0; i < n - 1; i += 1) {
    fn(...args);
  }
  return fn(...args);
}

function step(initialValue) {
  let x0 = initialValue;
  let x = initialValue;

  return (xt, opts = {}) => {
    if (opts.hard) {
      x = x0 = xt;
      return [x, true];
    } else {
      const { stiffness, damping, mass } = opts;
      const velocity = (x - x0) / stepTime;
      const springForce = -stiffness * (x - xt);
      const dampingForce = -damping * velocity;
      const acceleration = (springForce + dampingForce) / mass;
      const dx = (velocity + acceleration * stepTime) * stepTime;
      if (Math.abs(x - xt) < 0.5 && Math.abs(dx) < 0.5) {
        x = x0 = xt;
        return [xt, true];
      } else {
        x0 = x;
        x += dx;
        return [x, false];
      }
    }
  };
}

/**
 * Creates a spring
 * @param initialValue {Array.<Number>}
 * @param options {{stiffness: Number, damping: Number, mass: Number=}}
 * @returns {import(observable).Observable & { set: function: Promise }}
 */
export function spring(initialValue = [], options = {}) {
  const { stiffness, damping, mass = 1 } = options;
  const stepArray = initialValue.map(x => step(x));
  const store = observable(initialValue);

  let targetValue;
  let settled = [];
  let timestamp;

  const springStep = rafThrottle((opts = {}) => {
    const value = [];
    const now = performance.now();
    timestamp = timestamp ?? now;
    const dt = (now - timestamp) / 1000;
    timestamp = now;
    const frames = Math.max(1, Math.round(dt / stepTime));
    for (let i = 0; i < targetValue.length; i += 1) {
      const xt = targetValue[i];
      if (settled[i]) {
        value[i] = xt;
        continue;
      }
      const [x, done] = repeat(frames, stepArray[i], xt, {
        stiffness,
        damping,
        mass,
        hard: opts.hard,
      });
      value[i] = x;
      settled[i] = done;
    }
    store.set(value);
    if (settled.every(Boolean)) {
      settled = [];
      timestamp = undefined;
      throw new AbortError();
    }
  });

  const springLoop = loop(springStep, springStep.cancel);

  return {
    async set(value, opts = {}) {
      targetValue = value;
      if (opts.hard) {
        springLoop.cancel();
        try {
          await springStep(opts);
        } catch (err) {
          assert(err instanceof AbortError, err);
        }
      } else {
        return springLoop();
      }
    },
    subscribe: store.subscribe,
    get current() {
      return store.current;
    },
  };
}
