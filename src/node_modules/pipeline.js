import { AbortError, assert } from 'errors';

/**
 * Runs provided sync|async tasks one by one passing prev task return value.
 * New calls to pipeline cancel prev calls.
 * @param tasks {(function(prevTaskReturnValue: *=, ...*): *)[]}
 * @return {((function(...[*]): Promise) & {cancel: cancel, readonly running: boolean})}
 */
export function pipeline(tasks = []) {
  let counter = 0;
  let running = true;

  const cancel = () => {
    running = false;
  };

  /**
   * @param args
   * @return {Promise}
   */
  const returnValue = async (...args) => {
    if (running === false) {
      running = true;
    }
    counter += 1;
    const c = counter;
    let prevTaskReturnValue = undefined;
    try {
      for (let i = 0; i < tasks.length; i += 1) {
        if (c === counter && running) {
          prevTaskReturnValue = await tasks[i](prevTaskReturnValue, ...args);
        } else {
          throw new AbortError();
        }
      }
      running = false;
    } catch (err) {
      assert(err instanceof AbortError, err);
    }
    return prevTaskReturnValue;
  };

  return Object.assign(returnValue, {
    cancel,
    get running() {
      return running;
    },
  });
}
