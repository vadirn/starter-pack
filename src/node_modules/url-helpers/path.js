import { ParseError, assert } from 'errors';

/**
 * Returns an array of pathname parts
 * @param {string} pathname
 * @returns {Array}
 */
export function splitPath(pathname) {
  let uri = decodeURIComponent(pathname);
  if (uri[0] === '/') {
    uri = uri.substr(1);
  }
  if (uri[uri.length - 1] === '/') {
    uri = uri.slice(0, -1);
  }
  return uri.split('/');
}

/**
 * Tries to parse provided pathname using provided route.
 * Returns parsed data or throws ParseError if route cannot be matched
 *
 * @param {spring} pathname
 * @param {spring} routestring
 */
export function parsePath(pathname, routestring) {
  const routeComponentArray = splitPath(routestring);
  const pathComponentArray = splitPath(pathname);

  assert(
    routeComponentArray.length === pathComponentArray.length,
    new ParseError()
  );

  const returnValue = {};

  for (let i = 0; i < routeComponentArray.length; i += 1) {
    const routeComponent = routeComponentArray[i];
    const pathComponent = pathComponentArray[i];
    if (routeComponent.startsWith(':')) {
      returnValue[routeComponent.slice(1)] = pathComponent;
    } else {
      assert(routeComponent === pathComponent, new ParseError());
    }
  }

  return returnValue;
}

/**
 * Returns a pathname from an object representations and route
 * @param {Object} path
 * @param {string} routestring
 * @returns {string}
 */
export function serializePath(routestring, path) {
  const routeComponentArray = splitPath(routestring);
  let returnValue = '';
  for (let routeComponent of routeComponentArray) {
    if (routeComponent.startsWith(':')) {
      const key = routeComponent.slice(1);
      assert(path[key] !== undefined, new ParseError());
      returnValue += `/${path[key]}`;
    } else {
      returnValue += `/${routeComponent}`;
    }
  }
  return returnValue;
}
