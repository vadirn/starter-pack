import { observable } from 'observable';
import { nil } from 'nil';

/**
 * Map over iterable
 * @param target {{forEach: function, size: number=, length: number=}}
 * @param fn {function}
 * @return {any[]}
 */
function map(target, fn = i => i) {
  const length = target?.size ?? target.length;
  const returnValue = new Array(length);
  let i = 0;
  target.forEach((val, _, t) => {
    returnValue[i] = fn(val, i, t);
    i += 1;
  });
  return returnValue;
}

export function scaffoldIndex(entries) {
  // key -> Set([cid, ...])
  // using map because key could be anything
  // using set because cid's should not be duplicated
  const cache = new Map();
  const tag = observable(0);
  const incrementTag = () => tag.set(tag.current + 1);

  /**
   * Return resources at key
   * @param key
   * @return {any[]}
   */
  const get = key => map(cache.get(key) ?? new Set(), cid => entries[cid]);

  /**
   * Add cid to a set at key (ignores undefined key)
   * @param key
   * @param cid {number} entry cid
   * @param atomic {boolean} if true increments tag
   */
  const add = (key, cid, atomic = true) => {
    if (nil(key)) return;
    const refs = cache.get(key) ?? new Set();
    const exists = refs.has(cid);
    refs.add(cid);
    cache.set(key, refs);
    if (atomic && !exists) {
      incrementTag();
    }
  };

  /**
   * Replace a set at key with a new set
   * @param key
   * @param refs {Set<number>}
   * @param atomic {boolean} if true increments tag
   */
  const set = (key, refs = new Set(), atomic = true) => {
    cache.set(key, refs);
    if (atomic) {
      incrementTag();
    }
  };

  /**
   * Remove cid appearance at key
   * @param key
   * @param cid {number}
   * @param atomic {boolean}
   */
  const remove = (key, cid, atomic = true) => {
    const refs = cache.get(key);
    refs?.delete(cid);
    if (refs.size === 0) {
      cache.delete(key);
    }
    if (atomic) {
      incrementTag();
    }
  };

  /**
   * Remove all cid appearances from index
   * @param cid {number}
   */
  const removeAll = cid => {
    for (const key of cache.keys()) {
      remove(cid, key, false);
    }
    incrementTag();
  };

  return {
    tag,
    cache,
    get,
    set,
    add,
    remove,
    removeAll,
    incrementTag,
  };
}
