import { observable, derived } from 'observable';
import { loop } from 'loop';
import { controlledPromise } from 'promise-helpers/controlled-promise';
import { AbortError, assert, requiredParam } from 'errors';
import { equal } from 'equal';

export function scaffoldResource(
  initialGroundValue,
  copy = v => JSON.parse(JSON.stringify(v))
) {
  const groundValue = observable(copy(initialGroundValue)); // <- usually response.data
  const events = observable([]); // <- keep track of pending edits
  const syncHandlers = {}; // <- event handlers to get eventualValue
  const asyncHandlers = {}; // <- event handlers to update groundValue
  const convergenceState = observable(Promise.resolve()); // <- promise that is resolved when all events are processed

  const pushEvent = (type = requiredParam(), ...args) => {
    const promise = controlledPromise();
    events.current.push({ type, args, promise });
    events.set(events.current);
    return promise;
  };

  const eventualValue = derived(
    events,
    (currentEvents, currentEventualValue) => {
      let accum = copy(groundValue.current);
      currentEvents.slice().forEach(({ type, args }) => {
        accum = syncHandlers[type]?.(accum, ...args) ?? accum;
      });
      if (equal(accum, currentEventualValue)) return;
      return accum;
    }
  );

  const eventLoop = loop(async () => {
    assert(events.current.length !== 0, new AbortError());
    const { type, args, promise } = events.current.slice(0, 1)[0];
    let accum = copy(groundValue.current);
    try {
      accum = (await asyncHandlers[type]?.(accum, ...args)) ?? accum;
      groundValue.set(accum);
      promise.resolve(eventualValue.current);
      events.current.splice(0, 1);
      events.set(events.current);
    } catch (err) {
      promise.reject(err);
      // clear events if one of them fails
      events.set([]);
    }
  });

  // restart events array change
  events.subscribe(currentEvents => {
    if (!eventLoop.running && currentEvents.length !== 0) {
      convergenceState.set(eventLoop());
    }
  });

  const addSyncHandler = (type, fn = () => {}) => {
    Object.assign(syncHandlers, { [type]: fn });
  };
  const addAsyncHandler = (type, fn = () => {}) => {
    Object.assign(asyncHandlers, { [type]: fn });
  };
  const addHandlers = (type, fn1, fn2) => {
    addSyncHandler(type, fn1);
    addAsyncHandler(type, fn2);
  };

  addHandlers('set', Object.assign, Object.assign); // <- default handler that sets groundValue directly

  return {
    groundValue,
    events,
    pushEvent,
    eventualValue,
    convergenceState,
    addSyncHandler,
    addAsyncHandler,
    addHandlers,
    set: data => pushEvent('set', data),
  };
}
